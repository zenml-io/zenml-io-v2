---
title: "AI-Powered Background Coding Agents for Large-Scale Software Maintenance"
slug: "ai-powered-background-coding-agents-for-large-scale-software-maintenance"
draft: false
webflow:
  siteId: "64a817a2e7e2208272d1ce30"
  itemId: "694ad78262d4a3172e9c963f"
  exportedAt: "2026-02-11T10:23:34.071Z"
  source: "live"
  lastPublished: "2026-01-07T09:40:39.763Z"
  lastUpdated: "2025-12-23T20:12:19.664Z"
  createdOn: "2025-12-23T17:55:14.553Z"
llmopsTags:
  - "code-generation"
  - "poc"
  - "prompt-engineering"
  - "multi-agent-systems"
  - "agent-based"
  - "human-in-the-loop"
  - "system-prompts"
  - "mcp"
  - "evals"
  - "kubernetes"
  - "docker"
  - "cicd"
  - "orchestration"
  - "continuous-integration"
  - "continuous-deployment"
  - "devops"
  - "fastapi"
  - "monitoring"
  - "documentation"
  - "guardrails"
  - "wandb"
  - "google-gcp"
company: "Spotify"
summary: "Spotify faced the challenge of scaling complex code migrations and maintenance tasks across thousands of repositories, where their existing Fleet Management system handled simple transformations well but required specialized expertise for complex changes. They integrated AI coding agents into their Fleet Management platform, allowing engineers to define fleet-wide code changes using natural language prompts instead of writing complex AST manipulation scripts. Since February 2025, this approach has generated over 1,500 merged pull requests handling complex tasks like language modernization, breaking API changes, and UI component migrations, achieving 60-90% time savings compared to manual implementation while expanding to ad hoc background coding tasks accessible via Slack and GitHub."
link: "https://engineering.atspotify.com/2025/11/spotifys-background-coding-agent-part-1"
year: 2025
seo:
  title: "Spotify: AI-Powered Background Coding Agents for Large-Scale Software Maintenance - ZenML LLMOps Database"
  description: "Spotify faced the challenge of scaling complex code migrations and maintenance tasks across thousands of repositories, where their existing Fleet Management system handled simple transformations well but required specialized expertise for complex changes. They integrated AI coding agents into their Fleet Management platform, allowing engineers to define fleet-wide code changes using natural language prompts instead of writing complex AST manipulation scripts. Since February 2025, this approach has generated over 1,500 merged pull requests handling complex tasks like language modernization, breaking API changes, and UI component migrations, achieving 60-90% time savings compared to manual implementation while expanding to ad hoc background coding tasks accessible via Slack and GitHub."
  canonical: "https://www.zenml.io/llmops-database/ai-powered-background-coding-agents-for-large-scale-software-maintenance"
  ogTitle: "Spotify: AI-Powered Background Coding Agents for Large-Scale Software Maintenance - ZenML LLMOps Database"
  ogDescription: "Spotify faced the challenge of scaling complex code migrations and maintenance tasks across thousands of repositories, where their existing Fleet Management system handled simple transformations well but required specialized expertise for complex changes. They integrated AI coding agents into their Fleet Management platform, allowing engineers to define fleet-wide code changes using natural language prompts instead of writing complex AST manipulation scripts. Since February 2025, this approach has generated over 1,500 merged pull requests handling complex tasks like language modernization, breaking API changes, and UI component migrations, achieving 60-90% time savings compared to manual implementation while expanding to ad hoc background coding tasks accessible via Slack and GitHub."
---

## Overview

Spotify has developed and deployed a production LLMOps system that integrates AI coding agents into their Fleet Management platform to automate complex software maintenance tasks across their entire codebase. This case study provides detailed insights into how a major technology company scaled LLM-based code generation to production, handling over 1,500 merged pull requests since starting their investigation in February 2025 (published November 2025). The system represents a mature LLMOps implementation that addresses real production challenges including agent orchestration, quality control, cost management, and integration with existing developer workflows.

## The Problem Context

Spotify's Fleet Management system had already automated significant amounts of developer toil by applying source-to-source transformations across thousands of repositories. By mid-2024, approximately half of Spotify's merged pull requests were automated by this system, demonstrating substantial scale. However, the existing approach had fundamental limitations. Complex code changes required writing transformation scripts that manipulated abstract syntax trees (AST) or used regular expressions, demanding specialized expertise that few teams possessed. A telling example: their automated Maven dependency updater grew to over 20,000 lines of code just to handle corner cases for what seemed like a straightforward task. This complexity created a barrier that prevented the platform from being used for more sophisticated migrations, limiting it primarily to simple, repeatable tasks like dependency bumps, configuration updates, and basic refactors.

The challenge was clear: how could they lower the barrier to entry and enable more complex transformations without requiring extensive AST manipulation expertise? The emerging capabilities of AI coding agents presented a promising opportunity to bridge this gap.

## Technical Architecture and LLMOps Implementation

Spotify's approach demonstrates sophisticated LLMOps architecture decisions. Rather than adopting an off-the-shelf coding agent solution wholesale, they built a custom internal CLI that provides crucial flexibility and integration capabilities. This CLI serves as an abstraction layer that can delegate prompt execution to different agents, run custom formatting and linting tasks using the Model Context Protocol (MCP), evaluate diffs using LLMs as judges, upload logs to Google Cloud Platform (GCP), and capture traces in MLflow.

The architectural decision to maintain this abstraction layer reveals important LLMOps thinking: in the rapidly evolving GenAI landscape, being able to swap out components (different agents, different LLMs) without disrupting user workflows is critical. This pluggability has already proven valuable as they've switched components multiple times. The system provides users with a preconfigured, well-integrated tool while shielding them from implementation details.

The integration into Fleet Management is surgical. They replaced only the deterministic migration script component with an agent that takes natural language instructions, while preserving all the surrounding infrastructure: repository targeting, pull request creation, code review workflows, and merging to production. This incremental approach reduced risk and allowed them to leverage years of investment in their existing automation platform.

## Agent Orchestration and Multi-Agent Architecture

The system has evolved into a multi-agent architecture for planning, generating, and reviewing pull requests. For ad hoc tasks (beyond scheduled migrations), Spotify exposed their background coding agent via MCP, making it accessible from both Slack and GitHub Enterprise. The workflow involves an interactive agent that first gathers information about the task through conversation with the user. This planning agent produces a refined prompt that gets handed off to the coding agent, which then generates the actual pull request.

This separation of concerns between planning/context gathering and code generation represents a mature understanding of agent orchestration patterns. The interactive front-end agent helps structure the problem and gather necessary context before committing to expensive code generation operations, improving both cost efficiency and output quality.

## Context Engineering and Prompt Engineering

While the source text references a follow-up post on "context engineering," the case study makes clear that prompt engineering is central to the system's success. Engineers define fleet-wide changes using natural language rather than code, which dramatically lowers the barrier to entry. The system includes configuration interfaces where users can specify transformation prompts that describe desired code changes.

The ability to have users interact with a workflow agent that helps gather information and refine the task description before generating code represents a sophisticated approach to context engineering. This iterative refinement process helps ensure the coding agent receives well-structured instructions with appropriate context, addressing one of the fundamental challenges in LLMOps: getting relevant information into the model's context window effectively.

## Quality Control and Validation

The case study is notably transparent about the challenges and tradeoffs of using AI agents in production. Performance and unpredictability are explicitly called out as key considerations. Agents can take considerable time to produce results, and their output is not deterministic. This creates a need for new validation and quality control mechanisms that differ from traditional software testing.

Spotify implemented several quality control measures:

- **LLM-as-Judge evaluation**: The CLI includes functionality to evaluate diffs using LLMs as judges, providing automated assessment of the generated code changes before they're submitted as pull requests.

- **Custom formatting and linting**: Integration with local MCP allows running project-specific formatting and linting tasks to ensure generated code adheres to style guidelines and catches basic issues.

- **Existing code review workflows**: By plugging into the established Fleet Management pull request process, generated code still goes through human review before merging, providing a critical human-in-the-loop safeguard.

The text references a follow-up post on "using feedback loops to achieve more predictable results," indicating they've developed systematic approaches to address the unpredictability challenge, though the specific mechanisms aren't detailed in this first post.

## Observability and Monitoring

The LLMOps implementation includes comprehensive observability infrastructure. The system captures traces in MLflow, a widely-used machine learning lifecycle platform, allowing Spotify to track agent behavior, performance, and outcomes over time. Logs are uploaded to Google Cloud Platform, providing centralized access to execution details for debugging and analysis.

This instrumentation is essential for production LLMOps systems. Unlike traditional software where behavior is deterministic, AI agents require continuous monitoring to detect quality degradation, performance issues, and unexpected behaviors. The MLflow integration suggests they're treating agent deployments with similar rigor to traditional ML model deployments, tracking metrics and potentially A/B testing different agent configurations or LLM versions.

## Safety and Sandboxing

The case study explicitly mentions safety as a key consideration, noting the need for "robust guardrails and sandboxing to ensure agents operate as intended." While specific implementation details aren't provided, the Fleet Management architecture inherently provides some safety boundaries: agents run in containerized environments, and generated code goes through pull request review before merging.

The fact that Spotify is running these agents against their production codebase—with over 1,500 changes merged—demonstrates they've achieved a level of safety and reliability necessary for production use. The containerization ensures agents can't directly affect production systems, and the pull request workflow provides a review gate.

## Cost Management

Cost is explicitly identified as a significant consideration, with the text noting the "significant computational expense of running LLMs at scale." The system includes functionality for "managing LLM quotas," indicating they've implemented controls to prevent runaway costs. This is a crucial LLMOps concern that many organizations underestimate when moving from prototype to production scale.

The fact that they've merged 1,500+ PRs suggests they've found a cost model that works for their use cases, though specific cost figures aren't disclosed. The 60-90% time savings compared to manual implementation provides a strong ROI argument, but managing the direct LLM API costs at scale requires active monitoring and controls.

## Production Use Cases and Impact

The system has moved beyond simple transformations to handle genuinely complex changes:

- **Language modernization**: Replacing Java value types with records, which requires understanding semantic equivalence and appropriate refactoring patterns
- **Breaking API migrations**: Updating data pipelines to newer versions of Scio (a Scala library for Apache Beam), requiring understanding of API changes and code adaptation
- **UI component migrations**: Moving to new frontend systems in Backstage, involving React component refactoring and API changes
- **Schema-aware configuration changes**: Updating YAML/JSON parameters while maintaining schema compliance and formatting conventions

These use cases represent real production complexity, not toy problems. The 60-90% time savings is measured against manual implementation, providing a concrete productivity metric. The ROI calculation explicitly accounts for scale: the cost of creating the automated change is amortized across potentially thousands of repositories, making the economics increasingly favorable as adoption grows.

The fact that hundreds of developers now interact with the agent, and that it's being used not just for migrations but for ad hoc tasks like capturing architecture decision records from Slack threads, demonstrates genuine adoption and utility. Having product managers propose simple changes without needing to clone and build repositories shows the system has successfully lowered the barrier to entry, which was a core objective.

## Integration with Developer Workflows

The multi-channel accessibility (Slack, GitHub, IDE integration mentioned as future direction) shows thoughtful integration with how developers actually work. The background agent model—where users can "kick off a task and go to lunch"—acknowledges that agent execution times may be long but positions this as acceptable for certain workflows.

The standardization benefits mentioned (commit tagging, quota management, trace collection) apply across both migration and ad hoc use cases, demonstrating good platform thinking. Building reusable infrastructure that serves multiple use patterns increases ROI and reduces maintenance burden.

## Transparent Assessment of Limitations and Trade-offs

The case study deserves credit for transparency about challenges and open questions. The authors explicitly state "we don't have all the answers yet" and acknowledge that agents "can take a long time to produce a result" with "unpredictable" output. This honest assessment of trade-offs is more valuable than marketing claims of perfect performance.

The evolution from simple dependency updates to complex migrations shows a realistic adoption curve. They didn't try to solve the hardest problems first but rather demonstrated value with simpler use cases before expanding scope. This pragmatic approach reduces risk and builds organizational confidence gradually.

The identification of "performance, predictability, safety, and cost" as the key challenge areas provides a useful framework for other organizations considering similar implementations. These are indeed the central concerns for production LLMOps systems, and acknowledging them explicitly demonstrates mature thinking about the space.

## LLMOps Maturity Indicators

This case study exhibits several markers of LLMOps maturity:

- **Abstraction and pluggability**: The custom CLI abstraction allows swapping components without disrupting users
- **Instrumentation**: MLflow traces and GCP logging provide comprehensive observability
- **Quality gates**: LLM-as-judge evaluation, linting, formatting, and human review create multiple validation layers
- **Cost controls**: Quota management prevents runaway expenses
- **Integration**: MCP integration and multi-channel access show sophisticated tooling integration
- **Scale**: 1,500+ merged PRs across hundreds of users demonstrates genuine production scale
- **Multi-agent orchestration**: Separation of planning and execution agents shows understanding of architectural patterns

The system represents a production-grade LLMOps implementation rather than an experiment or prototype.

## Open Questions and Future Directions

The authors indicate follow-up posts will cover "effective context engineering" and "feedback loops to achieve more predictable results," suggesting these are areas of active development. The mention that they're "only scratching the surface" of what's possible indicates they see significant room for expansion.

The ad hoc background agent use case appears to be emerging organically from the migration use case, suggesting the platform's value proposition extends beyond the original design intent. This kind of organic expansion is a positive signal for platform adoption.

The case study doesn't provide specific accuracy metrics (e.g., percentage of generated PRs that pass review, percentage requiring human modification), which would be valuable for assessing true automation levels. The 60-90% time savings metric is useful but doesn't fully capture quality or reliability. However, the fact that 1,500+ PRs have merged into production provides strong evidence that quality is sufficient for real use.

## Conclusion

Spotify's background coding agent system represents a sophisticated LLMOps implementation that has achieved genuine production scale and impact. By integrating AI agents into their existing Fleet Management platform, they've lowered the barrier to complex code migrations while maintaining safety through containerization, review workflows, and quality controls. The custom CLI abstraction, MLflow instrumentation, and multi-agent architecture demonstrate mature LLMOps practices. The transparent discussion of challenges around performance, unpredictability, cost, and safety provides valuable insights for other organizations pursuing similar capabilities. With over 1,500 merged PRs and hundreds of active users, the system has moved beyond experiment to become a genuine productivity tool for large-scale software maintenance.