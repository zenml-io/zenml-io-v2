---
title: "ZenML sets up Great Expectations for continuous data validation in your ML pipelines"
slug: "zenml-sets-up-great-expectations-for-continuous-data-validation-in-your-ml-pipelines"
draft: false
webflow:
  siteId: "64a817a2e7e2208272d1ce30"
  itemId: "6531760b1eb2b69f30e2b581"
  exportedAt: "2026-02-11T10:23:34.071Z"
  source: "live"
  lastPublished: "2024-08-21T12:32:08.204Z"
  lastUpdated: "2024-08-21T12:27:25.240Z"
  createdOn: "2023-10-19T18:31:39.296Z"
author: "stefan-nica"
category: "zenml"
tags:
  - "zenml"
  - "evergreen"
  - "integrations"
  - "mlops"
  - "monitoring"
  - "tooling"
date: "2022-07-07T00:00:00.000Z"
readingTime: 18 Mins Read
mainImage:
  url: "https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/b4253d43/653173fbd3f284555af57536_continuous-data-validation.png"
seo:
  title: "ZenML sets up Great Expectations for continuous data validation in your ML pipelines - ZenML Blog"
  description: "ZenML combines forces with Great Expectations to add data validation to the list of continuous processes automated with MLOps. Discover why data validation is an important part of MLOps and try the new integration with a hands-on tutorial."
  canonical: "https://www.zenml.io/blog/zenml-sets-up-great-expectations-for-continuous-data-validation-in-your-ml-pipelines"
  ogImage: "https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/b9f3df1f/653173fbd3f284555af57536_continuous-data-validation.png"
  ogTitle: "ZenML sets up Great Expectations for continuous data validation in your ML pipelines - ZenML Blog"
  ogDescription: "ZenML combines forces with Great Expectations to add data validation to the list of continuous processes automated with MLOps. Discover why data validation is an important part of MLOps and try the new integration with a hands-on tutorial."
---

**Last updated:** October 17, 2022.

ZenML is constantly extending its coverage to cover more and more areas of what is slowly but surely becoming the standard set of best practices and tooling that a mature MLOps framework has to provide, as detailed [in a previous post](https://blog.zenml.io/zenml-mlops-framework/). It should therefore come as no surprise that the ZenML team views data validation as a vital area of concern for MLOps, especially given the data-centric nature of ML development.

[Great Expectations](https://greatexpectations.io/) is the first ZenML *Data Validator*, a new category of libraries and frameworks that [the 0.10.0 ZenML release](https://blog.zenml.io/zero-ten-zero-release/) adds to the ZenML ecosystem of integrations. *Data Validators* are MLOps tool stack components that allow you to define high data quality standards and practices and to apply them throughout the entire lifecycle of a ML project.

## Some Introductory Terminology

Before we begin exploring the range of Great Expectations features and how they fit like puzzle pieces into the ZenML MLOps ecosystem, we should get some Great Expectations terminology out of the way. Feel free to skip ahead, if these terms are already familiar to you:

<ul id=""><li id=""><em id="">Expectations</em> can be thought of as declarative data validation rules. They are the core concept of the Great Expectations framework.</li><li id=""><em id="">Expectation Suites</em> are collections of <em id="">Expectations</em>.</li><li id="">A <em id="">Validation Result</em> is an object generated when data is validated against an <em id="">Expectation</em> or <em id="">Expectation Suite</em>.</li><li id=""><em id="">Data Docs</em> are human readable documentation generated by Great Expectations detailing <em id="">Expectations</em>, <em id="">Validation Results</em> and other metadata information.</li><li id="">The <em id="">Data Context</em> is the primary API entry point for Great Expectations. It wraps the Great Expectations deployment configuration and provides methods to manage all supporting components.</li><li id=""><em id="">Data Sources</em> and <em id="">Batch Requests</em> are standard APIs used to access and interact with data.</li></ul>

## Why Great Expectations?

Our decision was not random nor incidental. We chose Great Expectations to be the baseline for our ZenML Data Validator concept not just because it is a popular, best-in-class data quality framework (though for those it scored high on our criteria list), but also because we share a similar vision about the role of data validation in MLOps. On top of that, they are a natural fit from an engineering perspective, which made designing and implementing the Great Expectations ZenML integration a pleasurable experience.

Convinced already? If yes, you should fast-forward to the next section to [dive into the integration itself](https://blog.zenml.io/great-expectations/#integration-tactics---how-did-we-do-it) or skip straight to the hands-on area to [look at some code examples](https://blog.zenml.io/great-expectations/#time-to-show-you-an-example-already). Otherwise, keep reading below to get more insight into what makes Great Expectations and ZenML a great pair.

### The Golden Path

ZenML and Great Expectations have compatible visions regarding the role of data validation and documentation in MLOps, the user experience and the general workflow of continuously validating the data that is circulated through ML pipelines. This is elegantly referred to as ‚Äúthe golden path‚Äù in a Great Expectations blog post entitled [How does Great Expectations fit into MLOps](https://greatexpectations.io/blog/ml-ops-great-expectations/).

### Reproducible Data Validation

The reproducible nature of ZenML pipelines achieved through artifact versioning and metadata tracking is perfectly aligned with Great Expectations‚Äô concept of [Data Docs](https://docs.greatexpectations.io/docs/terms/data_docs), a human readable view into the overall data quality state of a project. When combined, they can provide a complete historical record of the data used in a ML project and its quality characteristics at various points in time, making it extremely useful for the visibility and explainability of a project.

### Keep Humans in the Loop

Not everything in MLOps can be automated, nor should it. ZenML features such as [Experiment Trackers](https://docs.zenml.io/stacks-and-components/component-guide/experiment-trackers), [Alerters](https://docs.zenml.io/stacks-and-components/component-guide/alerters), artifact Visualizers and the [post-execution workflow](https://docs.zenml.io/user-guide/starter-guide/fetch-runs-after-execution) features are designed with this very principle in mind. They give users an easily comprehensible view into the otherwise complex structure of the information collected and stored throughout the lifecycle of a ML project.

The Great Expectations ‚Äútests are docs and docs are tests‚Äù principle fits perfectly into that story and the rendered Data Docs are a great way of facilitating collaboration and interaction between the various roles that are part of the ML team.

### Combined Extensibility

Great Expectation is a highly extensible framework. More than just another similarity between the ZenML and Great Expectations framework goals, this was vital to implementing a clean and elegant integration between the two frameworks and guarantees a maintainable relationship in the future.

## Integration Tactics - How Did We Do It?

<figure id="" class="w-richtext-figure-type-video w-richtext-align-normal" style="padding-bottom:33.75%" data-rt-type="video" data-rt-align="normal" data-rt-max-width="" data-rt-max-height="33.75%" data-rt-dimensions="0:0" data-page-url=""><div id=""><iframe src="https://giphy.com/embed/cn9lRpqz2kERy59R8w" frameborder="0" allowfullscreen=""></iframe></div></figure>

[via GIPHY](https://giphy.com/gifs/enbw-reaction-reactions-meme-cn9lRpqz2kERy59R8w)

The ZenML integration leverages a few surprising similarities in how both Great Expectations and ZenML handle configuration and data to make data validation a continuous operation that is automated and tracked through ML pipelines.

### ü§Ø The ZenML Artifact Store is a Great Expectations Store

The information managed by Great Expectations such as Expectation Suites, Validation Results and Data Docs need to be stored in some form of persistent storage. This can be your local filesystem or a cloud object storage service such as AWS S3, GCS or Azure Blob Storage. Great Expectations includes support for all of these types of object storage.

Perhaps the most rewarding aspect of the ZenML integration is how we coupled the Great Expectations Store and the ZenML Artifact Store concepts. When registered as a ZenML *Data Validator* stack component, Great Expectations is by default configured to store Expectation Suites, Validation Results, Data Docs and other artifacts in the ZenML Artifact Store:**‚Äç**

**‚Äç**

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
zenml integration install great_expectations
zenml data-validator register great_expectations --flavor=great_expectations
zenml stack register ge_stack -m default -o default -a default -dv great_expectations --set
</code></pre></div>

**‚Äç**

To use this feature with your existing Great Expectations code, you only need to use the Data Context managed by ZenML instead of the default one provided by Great Expectations:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
import great_expectations as ge
from zenml.integrations.great_expectations.data_validators import (
 &nbsp; &nbsp;GreatExpectationsDataValidator
)

context = GreatExpectationsDataValidator.get_data_context()
# instead of:
# context = ge.get_context()

context.add_data_source(...)
context.add_checkpoint(...)
context.run_checkpoint(...)
context.build_data_docs(...)
...
</code></pre></div>

‚Äç

This has added advantages:

<ul id=""><li id="">all the artifacts produced by your project will be stored in the same place: Great Expectations artifacts and ZenML pipeline artifacts.</li><li id="">you don‚Äôt need to worry about manually adjusting the Great Expectations deployment configuration if you don‚Äôt want to. It‚Äôs all done automatically for you. Of course, <a href="https://apidocs.zenml.io/0.10.0/api_docs/integrations/#zenml.integrations.great_expectations.data_validators.ge_data_validator.GreatExpectationsDataValidator" id="">the ZenML integration gives you plenty of options</a>, should you choose to migrate your existing Great Expectations configuration to ZenML, or to customize your configuration.</li><li id="">Great Expectations transparently works with any and all present and future <a href="https://docs.zenml.io/stacks-and-components/component-guide/artifact-stores" id="">types of ZenML Artifact Store</a>: local filesystem, AWS S3, GCS, Azure Blob Storage as well as any custom Artifact Store implementation.</li><li id="">ZenML users can manage multiple Great Expectation deployment configurations and switch between them as easily as switching ZenML Stacks.</li></ul>

The example featured later in this article shows how straightforward it is to configure and switch between two different Great Expectations ZenML deployment scenarios, one using the local filesystem, the other using AWS S3.

The extensibility of Great Expectations was key to implementing this integration feature. ZenML extends the TupleStoreBackend base class and implements a new flavor of Great Expectations Store that redirects all calls to the Artifact Store API. In fact, storing Great Expectations metadata in the active ZenML Artifact Store can be done even without the ZenML Data Validator, by simply using the ZenML store backend in your Great Expectations configuration, e.g.:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
stores:
 &nbsp;expectations_store:
 &nbsp; &nbsp;class_name: ExpectationsStore
 &nbsp; &nbsp;store_backend:
 &nbsp; &nbsp; &nbsp;module_name: zenml.integrations.great_expectations.ge_store_backend
 &nbsp; &nbsp; &nbsp;class_name: ZenMLArtifactStoreBackend
 &nbsp; &nbsp; &nbsp;prefix: great_expectations/expectations

 &nbsp;validations_store:
 &nbsp; &nbsp;class_name: ValidationsStore
 &nbsp; &nbsp;store_backend:
 &nbsp; &nbsp; &nbsp;module_name: zenml.integrations.great_expectations.ge_store_backend
 &nbsp; &nbsp; &nbsp;class_name: ZenMLArtifactStoreBackend
 &nbsp; &nbsp; &nbsp;prefix: great_expectations/validations
...
</code></pre></div>

‚Äç

### Expectation Suites and Validation Results as Pipeline Artifacts

One of the key ZenML features is the ability to automatically version and store all the artifacts generated from its pipeline steps. This maintains a clear historical record of operations that facilitates model and data tracking and lineage.

We recognized the need to add Expectation Suites and Validation Results to this historical record as artifacts involved in the pipeline execution. As a result, the integration also includes [ZenML Materializers](https://docs.zenml.io/user-guide/advanced-guide/handle-custom-data-types)(mechanisms for serializing and storing artifacts in persistent storage) for these data types, allowing ZenML users to use Expectation Suites and Validation Results as return values in their pipeline steps, as exemplified below:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
import pandas as pd
from great_expectations.checkpoint.types.checkpoint_result import (
 &nbsp; &nbsp;CheckpointResult,
)
from zenml.integrations.great_expectations.data_validators import (
 &nbsp; &nbsp;GreatExpectationsDataValidator
)
from zenml.steps import BaseStepConfig, step

class DataValidatorConfig(BaseStepConfig):
 &nbsp; &nbsp;expectation_suite_name: str

def data_validator(
 &nbsp; &nbsp;dataset: pd.DataFrame,
 &nbsp; &nbsp;config: DataValidatorConfig,
) -&gt; CheckpointResult:
 &nbsp; &nbsp;"""Example Great Expectations data validation step.

 &nbsp; &nbsp;Args:
 &nbsp; &nbsp; &nbsp; &nbsp;dataset: The dataset to run the expectation suite on.
 &nbsp; &nbsp; &nbsp; &nbsp;config: The configuration for the step.

 &nbsp; &nbsp;Returns:
 &nbsp; &nbsp; &nbsp; &nbsp;The Great Expectations validation (checkpoint) result.
 &nbsp; &nbsp;"""
 &nbsp; &nbsp;context = GreatExpectationsDataValidator.get_data_context()

 &nbsp; &nbsp;results = run_a_checkpoint_validation_check_on_runtime_data(
 &nbsp; &nbsp; &nbsp; &nbsp;dataset = dataset,
 &nbsp; &nbsp; &nbsp; &nbsp;expectation_suite_name=config.expectation_suite_name,
 &nbsp; &nbsp;)

 &nbsp; &nbsp;return results
</code></pre></div>

‚Äç

It was relatively easy to serialize/deserialize Expectation Suites and Validation Results, given that the Great Expectations library is already well equipped to handle these operations for most of its objects. This is another testament to how flexible the Great Expectations library really is.

### ZenML Visualizer for Great Expectations Data Docs

Another useful ZenML feature is the ability to visualize pipeline artifacts, either in a notebook environment or by opening generated HTML content in a browser.

The Great Expectations Data Docs concept fits perfectly with the ZenML Visualizer mechanism. A Great Expectations ZenML Visualizer is included in the integration to provide easy access to the Data Docs API, as showcased in the example included in this article.

### Standard Great Expectations Data Profiling and Data Validation Pipeline Steps

Finally, it is customary to include some builtin pipeline steps with every ZenML integration, if possible. Great Expectations is no exception, as we included two standard steps that can be quickly plugged into any pipeline to perform the following operations powered by Great Expectations:

<ul id=""><li id="">data profiling - generating and returning an Expectation Suite from an input dataset.</li><li id="">data validation - validating a dataset against an existing Expectation Suite and returning the results.</li></ul>

The builtin steps automatically configure temporary data sources and batch requests therefore simplifying the process of configuring Great Expectations even further.

## üëÄ Time to Show You An Example Already!

<figure id="" class="w-richtext-figure-type-video w-richtext-align-normal" style="padding-bottom:33.75%" data-rt-type="video" data-rt-align="normal" data-rt-max-width="" data-rt-max-height="33.75%" data-rt-dimensions="0:0" data-page-url=""><div id=""><iframe src="https://giphy.com/embed/I24hjk3H0R8Oc" frameborder="0" allowfullscreen=""></iframe></div></figure>

[via GIPHY](https://giphy.com/gifs/excited-yes-30-rock-I24hjk3H0R8Oc)

If you reached this section, you‚Äôre probably eager to look at some code to get a feel of the Great Expectations ZenML integration. You are in the right place.

The example featured here consists of two stages. The first stage describes how to install ZenML and set up two different ZenML stack configurations, one local, the other using a cloud Artifact Store to store both Great Expectations and ZenML pipeline artifacts. The second stage defines a ZenML data validation pipeline with Great Expectations and shows how to run it on top of those stacks with similar results.

A similar, up-to-date version of this example can be accessed in [the ZenML GitHub repository](https://docs.zenml.io/stacks-and-components/component-guide/data-validators/great-expectations).

### Setup ZenML

You can run the following to install ZenML on your machine (e.g. in a Python virtual environment) as well as the Great Expectations and scikit-learn integrations used in the example:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
pip install zenml
zenml integration install great_expectations sklearn -y
</code></pre></div>

‚Äç**‚Äç**‚Äç

The next subsections show how to configure two different ZenML Stacks, both featuring Great Expectations as a Data Validator, but with different Artifact Stores:

<ul id=""><li id="">a local artifact store that uses the local filesystem as a backend</li><li id="">a cloud artifact store that uses a managed object storage service (AWS S3) as a backend.</li></ul>

The relevance of using two different stacks will become more obvious in the next stage. ZenML pipelines are portable, allowing the same pipeline to be executed on different stacks with literally no code changes required and this now also includes Great Expectations powered pipelines.

#### The Local Stack

The local ZenML stack leverages the compute and storage resources on your local machine. To register and activate a stack that includes a Great Expectations Data Validator and a local Artifact Store, run the following:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
zenml data-validator register great_expectations_local \
 &nbsp; &nbsp;--flavor=great_expectations

zenml stack register local_stack \
 &nbsp; &nbsp;-m default \
 &nbsp; &nbsp;-o default \
 &nbsp; &nbsp;-a default \
 &nbsp; &nbsp;-dv great_expectations_local
</code></pre></div>

‚Äç

When this stack is active, Great Expectations will use the local filesystem to store metadata information such as Expectation Suites, Validation Results and Data Docs.

#### The Cloud Storage Stack

This is a ZenML stack that includes an Artifact Store connected to a cloud object storage. This example uses AWS as a backend, but [the ZenML documentation](https://docs.zenml.io/) has similar instructions on how to configure a GCP or Azure Blob Storage powered Artifact Store.

For this stack, you will need an S3 bucket where our ML artifacts can later be stored. You can do so by following [this AWS tutorial](https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html).

The path for your bucket should be in this format: s3://your-bucket.

To register a stack that includes a Great Expectations Data Validator and an AWS S3 Artifact Store, run the following:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
zenml integration install s3 -y

zenml artifact-store register s3_store \
 &nbsp; &nbsp;--flavor=s3 \
 &nbsp; &nbsp;--path=s3://your-bucket

zenml data-validator register great_expectations_s3 \
 &nbsp; &nbsp;--flavor=great_expectations

zenml stack register s3_stack \
 &nbsp; &nbsp;-m default \
 &nbsp; &nbsp;-o default \
 &nbsp; &nbsp;-a s3_store \
 &nbsp; &nbsp;-dv great_expectations_s3
</code></pre></div>



When this stack is active, Great Expectations will use the same storage backend as the Artifact Store (i.e. AWS S3) to store metadata information such as Expectation Suites, Validation Results and Data Docs. A local version of the Data Docs will also be rendered, to allow them to be visualized locally.

### Run a ZenML Data Validation Pipeline

Now let‚Äôs see the Great Expectations Data Validator in action with a simple data validation pipeline example.

The following code defines two different pipelines, a profiling_pipeline that infers an Expectation Suite from a reference dataset and a validation_pipeline that uses the generated Expectation Suite to validate a second dataset. The generated Expectation Suite and the Validation Results returned from the validation pipeline are then both visualized:**‚Äç**

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
import pandas as pd
from sklearn import datasets

from zenml.integrations.constants import GREAT_EXPECTATIONS, SKLEARN
from zenml.integrations.great_expectations.steps import (
 &nbsp; &nbsp;GreatExpectationsProfilerConfig,
 &nbsp; &nbsp;GreatExpectationsProfilerStep,
 &nbsp; &nbsp;GreatExpectationsValidatorConfig,
 &nbsp; &nbsp;GreatExpectationsValidatorStep,
)
from zenml.integrations.great_expectations.visualizers import (
 &nbsp; &nbsp;GreatExpectationsVisualizer,
)
from zenml.pipelines import pipeline
from zenml.repository import Repository
from zenml.steps import BaseStepConfig, Output, step

class DataLoaderConfig(BaseStepConfig):
 &nbsp; &nbsp;reference_data: bool = True

@step
def importer(
 &nbsp; &nbsp; &nbsp; &nbsp;config: DataLoaderConfig,
) -&gt; Output(dataset=pd.DataFrame, condition=bool):
 &nbsp; &nbsp;"""Load the breast cancer dataset.
 &nbsp; &nbsp;
 &nbsp; &nbsp;This step is used to simulate loading data from two different sources.
 &nbsp; &nbsp;If `reference_data` is set in the step configuration, a slice of the
 &nbsp; &nbsp;data is returned as a reference dataset. Otherwise, a different slice
 &nbsp; &nbsp;is returned as a test dataset to be validated.
 &nbsp; &nbsp;"""
 &nbsp; &nbsp;breast_cancer = datasets.load_breast_cancer()
 &nbsp; &nbsp;df = pd.DataFrame(
 &nbsp; &nbsp; &nbsp; &nbsp;data=breast_cancer.data, columns=breast_cancer.feature_names
 &nbsp; &nbsp;)
 &nbsp; &nbsp;df["class"] = breast_cancer.target
 &nbsp; &nbsp;if config.reference_data:
 &nbsp; &nbsp; &nbsp; &nbsp;dataset = df[100:] 
 &nbsp; &nbsp;else:
 &nbsp; &nbsp; &nbsp; &nbsp;dataset = df[:100]
 &nbsp; &nbsp;return dataset, config.reference_data

# instantiate a builtin Great Expectations data profiling step
ge_profiler_config = GreatExpectationsProfilerConfig(
 &nbsp; &nbsp;expectation_suite_name="breast_cancer_suite",
 &nbsp; &nbsp;data_asset_name="breast_cancer_ref_df",
)
ge_profiler_step = GreatExpectationsProfilerStep(config=ge_profiler_config)


# instantiate a builtin Great Expectations data validation step
ge_validator_config = GreatExpectationsValidatorConfig(
 &nbsp; &nbsp;expectation_suite_name="breast_cancer_suite",
 &nbsp; &nbsp;data_asset_name="breast_cancer_test_df",
)
ge_validator_step = GreatExpectationsValidatorStep(config=ge_validator_config)


@pipeline(
 &nbsp; &nbsp;enable_cache=False, required_integrations=[SKLEARN, GREAT_EXPECTATIONS]
)
def profiling_pipeline(
 &nbsp; &nbsp;importer, profiler
):
 &nbsp; &nbsp;"""Data profiling pipeline for Great Expectations.

 &nbsp; &nbsp;The pipeline imports a reference dataset from a source then uses the builtin
 &nbsp; &nbsp;Great Expectations profiler step to generate an expectation suite (i.e.
 &nbsp; &nbsp;validation rules) inferred from the schema and statistical properties of the
 &nbsp; &nbsp;reference dataset.

 &nbsp; &nbsp;Args:
 &nbsp; &nbsp; &nbsp; &nbsp;importer: reference data importer step
 &nbsp; &nbsp; &nbsp; &nbsp;profiler: data profiler step
 &nbsp; &nbsp;"""
 &nbsp; &nbsp;dataset, _ = importer()
 &nbsp; &nbsp;profiler(dataset)

@pipeline(
 &nbsp; &nbsp;enable_cache=False, required_integrations=[SKLEARN, GREAT_EXPECTATIONS]
)
def validation_pipeline(
 &nbsp; &nbsp;importer, validator,
):
 &nbsp; &nbsp;"""Data validation pipeline for Great Expectations.

 &nbsp; &nbsp;The pipeline imports a test data from a source, then uses the builtin
 &nbsp; &nbsp;Great Expectations data validation step to validate the dataset against
 &nbsp; &nbsp;the expectation suite generated in the profiling pipeline.

 &nbsp; &nbsp;Args:
 &nbsp; &nbsp; &nbsp; &nbsp;importer: test data importer step
 &nbsp; &nbsp; &nbsp; &nbsp;validator: dataset validation step
 &nbsp; &nbsp;"""
 &nbsp; &nbsp;dataset, condition = importer()
 &nbsp; &nbsp;validator(dataset, condition)

def visualize_results(pipeline_name: str, step_name: str) -&gt; None:
 &nbsp; &nbsp;repo = Repository()
 &nbsp; &nbsp;pipeline = repo.get_pipeline(pipeline_name)
 &nbsp; &nbsp;last_run = pipeline.runs[-1]
 &nbsp; &nbsp;step = last_run.get_step(name=step_name)
 &nbsp; &nbsp;GreatExpectationsVisualizer().visualize(step)

if __name__ == "__main__":
 &nbsp; &nbsp;profiling_pipeline(
 &nbsp; &nbsp; &nbsp; &nbsp;importer=importer(config=DataLoaderConfig(reference_data=True)),
 &nbsp; &nbsp; &nbsp; &nbsp;profiler=ge_profiler_step,
 &nbsp; &nbsp;).run()

 &nbsp; &nbsp;validation_pipeline(
 &nbsp; &nbsp; &nbsp; &nbsp;importer=importer(config=DataLoaderConfig(reference_data=False)),
 &nbsp; &nbsp; &nbsp; &nbsp;validator=ge_validator_step,
 &nbsp; &nbsp;).run()

 &nbsp; &nbsp;visualize_results("profiling_pipeline", "profiler")
 &nbsp; &nbsp;visualize_results("validation_pipeline", "validator")
</code></pre></div>

**‚Äç**

In order to run this code, simply copy it into a file called run.py and run it with:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
zenml stack set s3_stack
python run.py
</code></pre></div>

‚Äç

You can switch to the cloud storage stack and run the same code with no code changes. The difference is that the Great Expectation Data Context is now configured to store its state in the cloud:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
zenml stack set s3_stack
python run.py
</code></pre></div>

‚Äç

Regardless of which stack you are using to run the pipelines, you should see the ZenML visualizer kicking in and opening two Data Docs tabs in your browser, one pointing to the Expectation Suite generated in the profiling pipeline run, the other pointing to the validation results from the data validation pipeline run.

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/7ececf58/6531740e948c96d5ccc1880a_data-docs-expectation-suite.png" alt="Data Docs Expectation Suite" />
</figure>

 

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/d6c8180b/6531740de96e79420f16981b_data-docs-validation-results.png" alt="Data Docs Validation Results" />
</figure>

### What Happened Here?

If you successfully installed ZenML and ran the example, you probably noticed that the Great Expectations validation result rendered in the Data Docs shows that the data validation has failed. This is to be expected with Expectation Suites automatically inferred from datasets, because these Expectations are intentionally over-fitted to the data in question.

The correct way to do this would probably be to run the profiling pipeline, then manually adjust the generated Expectation Suite, and then to run the validation pipeline as a final step. This re-validates the argument that data quality cannot be fully automated and there needs to be a high level of awareness and responsibility from ML project members regarding the characteristics of the data used by the project.

## It‚Äôs a Wrap!

The Great Expectations ZenML integration makes it a breeze to enhance your ML pipelines with data validation logic and gives you direct and easy access to all of the well-designed benefits that come with the Great Expectations library, such as inferring validation rules from datasets and auto-generated Data Docs. Employing data validation early in your ML workflows helps to keep your project on track and to identify and even prevent problems before they negatively impact the performance of the models running in production.

üî• Do you use data validation tools with your ML pipelines, or do you want to add one to your MLOps stack? At ZenML, **we are looking for design partnerships and collaboration** to develop the integrations and workflows around using data validation within the MLOps lifecycle. If you have a use case which requires data validation in your pipelines, **please let us know what you‚Äôre building**. Your feedback will help set the stage for the next generation of MLOps standards and best practices. The easiest way to contact us is via our Slack community which [you can join here](https://zenml.io/slack-invite/).

If you have any questions or feedback regarding the Great Expectations integration or the tutorial featured in this article, we encourage you to join our [weekly community hour](https://www.eventbrite.com/e/zenml-meet-the-community-tickets-354426688767).

If you want to know more about ZenML or see more examples, check out our [docs](https://docs.zenml.io/) and [examples](https://github.com/zenml-io/zenml/tree/main/examples).

‚Äç**Last updated:** October 17, 2022.ZenML is constantly extending its coverage to cover more and more areas of what is slowly but surely becoming the standard set of best practices and tooling that a mature MLOps framework has to provide, as detailed [in a previous post](https://blog.zenml.io/zenml-mlops-framework/). It should therefore come as no surprise that the ZenML team views data validation as a vital area of concern for MLOps, especially given the data-centric nature of ML development.