---
title: "How we made our integration tests delightful by optimizing the way our GitHub Actions run our test suite"
slug: "how-we-made-our-integration-tests-delightful-by-optimizing-the-way-our-github-actions-run-our-test-suite"
draft: false
webflow:
  siteId: "64a817a2e7e2208272d1ce30"
  itemId: "6530139f81c07f262b73aa3b"
  exportedAt: "2026-02-11T10:23:34.071Z"
  source: "live"
  lastPublished: "2023-10-19T09:13:46.292Z"
  lastUpdated: "2023-10-18T17:34:49.833Z"
  createdOn: "2023-10-18T17:19:25.721Z"
author: "alexej-penner"
category: "tech-startup"
tags:
  - "open-source"
  - "python"
  - "tech-startup"
  - "tooling"
date: "2022-03-09T00:00:00.000Z"
readingTime: 16 Mins Read
mainImage:
  url: "https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/6ad52faa/6530131b35b49e6493e2dc08_gh_actions.png"
seo:
  title: "How we made our integration tests delightful by optimizing the way our GitHub Actions run our test suite - ZenML Blog"
  description: "As we outgrew our initial template Github Action workflow, here's the five things we added to our Github Action arsenal to fit our growing needs: Caching, Reusable Workflows, Composite Actions, Comment Triggers and Concurrency Management."
  canonical: "https://www.zenml.io/blog/how-we-made-our-integration-tests-delightful-by-optimizing-the-way-our-github-actions-run-our-test-suite"
  ogImage: "https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/e1e03683/6530131b35b49e6493e2dc08_gh_actions.png"
  ogTitle: "How we made our integration tests delightful by optimizing the way our GitHub Actions run our test suite - ZenML Blog"
  ogDescription: "As we outgrew our initial template Github Action workflow, here's the five things we added to our Github Action arsenal to fit our growing needs: Caching, Reusable Workflows, Composite Actions, Comment Triggers and Concurrency Management."
---

**Last updated:** October 17, 2022.

# üìç What‚Äôs the point of Github Actions?

Software projects are complex beasts with a multitude of moving pieces that can affect each other in surprising ways. If you‚Äôre reading this then chances are, you‚Äôve been part of such projects where you have to build and improve software while ensuring you don‚Äôt break anything in the process. Testing and code standards are the main antidote at your disposal. As such these two tools should be considered integral parts of the software development lifecycle to allow for Continuous Integration.

The first thing that pops up when you search for the term ‚ÄòContinuous Integration‚Äô is the following definition: ‚ÄòContinuous integration (CI) is the practice of automating the integration of code changes from multiple contributors into a single software project.‚Äô A big part of CI is automated quality control before allowing the new code to be merged into the productive codebase. This quality control can get arbitrarily complex, layered and even convoluted. As such it is important to grow your quality control framework at the same pace as your product increases in scale and complexity.

This quality control can address multiple different aspects of the code. Static code analysis, otherwise known as [linting](https://www.perforce.com/blog/qac/what-lint-code-and-why-linting-important), is one such aspect of code quality control. Linting deals with programmatic and stylistic issues, such as making sure typed inputs and outputs match up. Unit and integration tests are also important ways of adding quality control your code.

The practice of DevOps aims to seamlessly integrate such quality control workflows into the development workflow. When you use Github for code versioning, you can use Github Actions as a tool that can orchestrate these code quality checks. Github Actions enables you to define workflows in *yaml* files. A ‚Äòworkflow‚Äô is a recipe of instructions that you would like to run at a given time.

‚ÄòWorkflows‚Äô can be equipped with triggers that define when it should run. Your workflow could run, for example, when someone makes a commit on a branch, creates a pull request for a specific branch or when manually triggered from the UI. Workflows contain one or more ‚Äòjobs‚Äô.

A ‚Äòjob‚Äô is a collection of instructions that is run on a virtual machine of its own. As such jobs are perfectly encapsulated from one another. The user can choose between a few operating systems for each ‚Äòjob‚Äô as part of the ‚Äòjob.strategy‚Äô attribute. However, when developing a Python library, you might want it to be tested on all operating systems and maybe even on multiple Python versions; enter ‚Äòstrategy matrices‚Äô. A matrix allows you to define a set of environment configurations. In our case we chose three operating systems (Linux, MacOS, Windows) and two different Python versions (3.7 and 3.8). The matrix then makes sure that the job is run for all six possible permutations of these configurations (eg MacOS + Python 3.7).

Finally, a job consists of one or many ‚Äòsteps‚Äô. Such steps can be defined through arbitrary command line commands. Bash scripts can be invoked, Python scripts can be called or you can use a plethora of steps produced by the broader community (see [Github Action Marketplace](https://github.com/marketplace?type=actions)). These community steps are called ‚Äòactions‚Äô. Steps can be executed conditionally. Importantly, all steps of a job run on the same machine. As such they can read and write to and from the same filesystem. Information from previous steps can also be directly accessed.

# üöÇ Where we start our journey

Here at ZenML, we‚Äôve made it our mission to build a tool that spans the complete development process of machine learning solutions in Python. Such a lofty vision comes with its own set of challenges. Not least of which is the shear scale of other tools that need to be integrated. You might have guessed where this is going. Many integrated tools implies a large number of integration tests. This is especially true if you also want to verify interoperability.

We start this journey in a very standard, cookie-cutter, monolithic workflow. I‚Äôm sure many projects start out this way. One yaml file defines a workflow that checks out the code, perform linting, unit testing, integration testing and uploading coverage to [codecov](https://codecov.io/) on a matrix of operating systems and Python versions. Here is one such sample of what the workflow used to look like.

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/1da12998/6530135a6ba489f168b0f1e2_oldActionSample.png" alt="Our original Github Actions" />
</figure>

One of the largest problems we ran into was the different dependencies each step needed and the consequential nightmare of unexpected upgrades or downgrades of some low-level packages. This would then lead to some confusing error messages and some very long debugging sessions, at the end of which our reaction was something like this:

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/1a3e727a/65301357f520e1e4ee16d612_turboFacepalm.png" alt="" />
</figure>

As you might imagine, the team was growing frustrated with the long testing times and the sporadic errors and a solution needed to be found. Here are five changes we implemented to upgrade our CI pipeline.

## ‚è© 1. Speed up your workflows with caching

Caching is a powerful way to speed up repeating processes. We run ‚Äòpoetry install‚Äô in one such process that is necessary for each aspect of our CI pipeline. We didn‚Äôt want to commit the ‚Äòpoetry.lock‚Äô file to ensure we would keep ZenML compatible with the newest versions of packages that we are integrating with and test regardless of the state on the developer‚Äôs machine. On average the [Poetry](https://python-poetry.org/) installation would take between 10-15 minutes for each cell on the OS-Python Version matrix.

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/af3bdc37/653013552d53663e49503174_dependencies.png" alt="Time taken by poetry install" />
</figure>

Using caching we are able to make this step nearly instantaneous, assuming a cached venv is available. See the *yaml* excerpt below to see how caching is done within a Github Actions workflow.

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
 &nbsp; &nbsp;...
 &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp;- name: Load cached venv
 &nbsp; &nbsp; &nbsp;id: cached-poetry-dependencies
 &nbsp; &nbsp; &nbsp;uses: actions/cache@v2.1.6
 &nbsp; &nbsp; &nbsp;with:
 &nbsp; &nbsp; &nbsp; &nbsp;path: |
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;.venv
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;poetry.lock
 &nbsp; &nbsp; &nbsp; &nbsp;# Cache the complete venv dir for a given os, python version, pyproject.toml
 &nbsp; &nbsp; &nbsp; &nbsp;key: venv-${{ runner.os }}-python-${{ matrix.python-version }}-${{ hashFiles('pyproject.toml') }}

 &nbsp; &nbsp;- name: Install Project
 &nbsp; &nbsp; &nbsp;shell: bash
 &nbsp; &nbsp; &nbsp;if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
 &nbsp; &nbsp; &nbsp;run: poetry install
 &nbsp; &nbsp;
 &nbsp; &nbsp;...
</code></pre></div>

‚Äç

{% endraw %}

As you can see the cache is saved with a unique key as a function of the runner operating system, the Python version and a hash of the ‚Äòpyproject.toml‚Äô. As a consequence the cache can be invalidated by changing the ‚Äòpyproject.toml‚Äô.

 **Note:** Unfortunately, this caching action currently does not give the user control over the exact moment in the pipeline when the cache is written to. As things currently stand, if there is no cache-hit then the cache entry is created at the end of the job. This means you need to structure your jobs purposefully in such a way that they reflect the state you want to cache, at their end.

The keen-minded among you might have caught on to an inconsistency in my argument from above. We don‚Äôt commit the ‚Äòpoetry.lock‚Äô file, as we want to always guarantee compatibility with the bleeding-edge changes of our integrations and dependencies. But by caching the virtual environment directory as a function of the ‚Äòpyproject.toml‚Äô, aren‚Äôt we just locking on to the versions when we cache for the first time? That is correct, however we now are not dependent on the state on a developer‚Äôs machine; instead we have a state for each combination of OS and Python version. On top of this, we can now decide on a cadence by which we periodically invalidate the cache.

 **Note:** Currently there is no way to explicitly invalidate the cache, so you‚Äôll have to use a workaround, like changing something innocuous in a hashed file, or to add date-stubs in the cache-key.

## üè≠ 2. Modularize your monolith with reusable workflows

The [Separation of Concerns (SoC)](https://nalexn.github.io/separation-of-concerns/) is an important principle in software development: ‚ÄúThe principle is simple: don‚Äôt write your program as one solid block, instead, break up the code into chunks that are finalized tiny pieces of the system each able to complete a simple distinct job.‚Äù This makes your code more understandable, reusable and maintainable.

In order to grow our Github Actions that meant splitting the monolithic workflow that was responsible for everything into multiple, sub-workflows with one purpose each. Luckily, Github Actions could do all this.

Reusable workflows are a way to use full-fledged workflows as jobs within an overarching workflow. In our case this means we have one CI workflow that calls the linting, unit test and integration test workflows respectively. This enables us to use any combination of these sub-workflows but also trigger them separately. What this also gives us is a perfect encapsulation of each separate job. Now our linting dependencies do not interfere with the integrations that we must install for our integration tests. This also allows us more fine-grained control over the runners, Python versions and other peripheral configurations that can now be done at the level of each ‚Äòreusable workflow.

Here‚Äôs an excerpt from our ‚Äòci.yml‚Äô file. Within the jobs section, we simply give each step in the job a name and call the corresponding reusable workflow. Within these reusable workflows themselves we just need to make sure to add workflow_call to the list of triggers under on:.

‚Äò.github/workflows/lint.yml‚Äô

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
name: Integration Test the Examples

on: workflow_call

jobs:
 &nbsp; &nbsp;...
</code></pre></div>



'.github/workflows/ci.yml'

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
jobs:
 &nbsp;poetry-install:
 &nbsp; &nbsp;uses: ./.github/workflows/poetry-install.yml

 &nbsp;lint-code:
 &nbsp; &nbsp;needs: poetry-install
 &nbsp; &nbsp;uses: ./.github/workflows/lint.yml

 &nbsp;unit-test:
 &nbsp; &nbsp;needs: poetry-install
 &nbsp; &nbsp;uses: ./.github/workflows/unit-test.yml

 &nbsp;integration-test:
 &nbsp; &nbsp;needs: poetry-install
 &nbsp; &nbsp;uses: ./.github/workflows/integration-test.yml
</code></pre></div>

‚Äç

> Note: Each reusable workflow takes the place of a job and is run on a separate machine. As such outputs from one job need to be defined as outputs/inputs explicitly to pass information between jobs.

As you can see the jobs that reference the different workflows have dependencies on one another. Here we make sure the ‚Äòpoetry install‚Äô only has to be done once per OS/Python version combination before branching into the three separate workflows. Currently, each of the sub-workflows are running on the same matrix.

> Note: One downside of this approach is that the ‚Äòpoetry-install‚Äô job is only considered done, when all six matrix cells are complete. This means even if the ubuntu/py3.8 runner is done with the ‚Äòpoetry-install‚Äô after 1 minute, the Ubuntu/Py3.8 runner for ‚Äòlint-code‚Äô can only start once every other runner on the ‚Äòpoetry-install‚Äô job are done.

## üîÅ 3. Avoid code duplication with composite actions

As we were designing the different reusable workflows it became obvious that we were generating a lot of duplicated code. Each workflow would set up Python, do some OS-specific fine-tuning, install Poetry and load the cached venv or create it.

This is where composite actions come into play. A composite action condenses multiple steps into one step and makes it usable as a step across all of your workflows. Here is a small example of how we use it.

In the ‚Äò.github‚Äô directory we create an ‚Äòactions‚Äô folder which in turn is populated by a folder for each composite action that you want to create ‚Äì in our case ‚Äò.github/actions/setup_environment‚Äô. Within this folder you then create a file with the name ‚Äòaction.yml‚Äô. Now you just need to add all your steps to the runs section and add the using: "composite" entry to it.

‚Äò.github/actions/setup_environment/action.yaml‚Äô 

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
runs:
 &nbsp;using: "composite"
 &nbsp;steps:
 &nbsp; &nbsp;- name: Set up Python
 &nbsp; &nbsp; &nbsp;uses: actions/setup-python@v2
 &nbsp; &nbsp; &nbsp;with:
 &nbsp; &nbsp; &nbsp; &nbsp;python-version: ${{ matrix.python-version }}

 &nbsp; &nbsp;- name: Install Poetry
 &nbsp; &nbsp; &nbsp;uses: snok/install-poetry@v1
 &nbsp; &nbsp; &nbsp;with:
 &nbsp; &nbsp; &nbsp; &nbsp;virtualenvs-create: true
 &nbsp; &nbsp; &nbsp; &nbsp;virtualenvs-in-project: true

 &nbsp; &nbsp;...
</code></pre></div>



All that is left to do now is reference this action from within your workflows to start using it.

'.github/workflows/lint.yml'

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
 &nbsp; &nbsp;...
 &nbsp; &nbsp; &nbsp;
 &nbsp; &nbsp;- name: Setup environment with Poetry
 &nbsp; &nbsp;uses: ./.github/actions/setup_environment

 &nbsp; &nbsp;...
</code></pre></div>

¬†

You might be asking yourself: ‚ÄúWhat is the difference between these ‚Äòcomposite actions‚Äô and ‚Äòreusable workflows‚Äô?‚Äù Short answer is, ‚Äòcomposite actions‚Äô are a collection of commands while ‚Äòreusable workflows‚Äô also contain information on where and how to be executed. For more information check out [this](https://chris48s.github.io/blogmarks/github/2021/11/06/composite-actions-reusable-workflows.html#:~:text=A%20composite%20action%20is%20presented,separately%20in%20the%20summary%20output.) blogpost that goes a bit more in detail on the differences.

## üí¨ 4. Expose control of Github Actions to developers with comment interaction

It is hard finding the correct atomized triggers for your workflows. ‚ÄúShould we run this on every pull request? Should we only run this on PRs from ‚Äòdev‚Äô to ‚Äòmain‚Äô? Should we run this only for changes within a given directory?‚Äù These are some questions you‚Äôll inevitably run into while growing with your CI pipeline. All these questions are useful ways to critically examine the motivations and reasons behind each part of your CI pipeline.

Automating most of these triggers helps ensure your code deployment runs smoothly with guaranteed checks in place. However, there are times when you want to have some more fine-grained control.

We ran into one such case at ZenML. One of our integrations is [Kubeflow Pipelines](https://www.kubeflow.org/docs/components/pipelines/). This integration needs to spin up a cluster of pods using [k3d](https://k3d.io/) in order to deploy Kubeflow Pipelines. Then all of our other integration tests are run on this cluster. This whole process takes about 1 hour to run and so it is not something we want running for each push on each PR. Instead, we want to have some control over when it is appropriate.

The first part of the fix to this problem is to include workflow_dispatch as one of the triggers for our reusable workflow that is dedicated to Kubeflow Pipelines integration tests. In order to make this even easier and more integrated into our normal workflow surrounding pull requests, we also added the ‚Äòpull-request-comment-trigger‚Äô action to our CI pipeline.

Given a specific comment on a pull request, the test gets activated for this PR, meaning that each commit on that PR will now trigger the specified Kubeflow Pipelines integration test.

As we are using the step as a basis to decide if a certain workflow should be executed, it needs to be part of a job of its own. As such we are explicitly defining the output of the ‚Äòcheck_comments‚Äô job, so it can be used to conditionally run the Kubeflow tests job.

‚Äò.github/workflows/ci.yml‚Äô

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
 &nbsp; &nbsp;...
 &nbsp; &nbsp;
on:
 &nbsp;pull_request:
 &nbsp; &nbsp;types: [opened, synchronize]
 &nbsp;issue_comment:
 &nbsp; &nbsp;types: [created]
 &nbsp; &nbsp;
 &nbsp; &nbsp;...

jobs:
 &nbsp;
 &nbsp;... 
 &nbsp;
 &nbsp;check_comments:
 &nbsp; &nbsp;runs-on: ubuntu-latest
 &nbsp; &nbsp;outputs:
 &nbsp; &nbsp; &nbsp;kf_trigger: ${{ steps.check.outputs.triggered }}
 &nbsp; &nbsp;steps:
 &nbsp; &nbsp; &nbsp;- uses: khan/pull-request-comment-trigger@master
 &nbsp; &nbsp; &nbsp; &nbsp;id: check
 &nbsp; &nbsp; &nbsp; &nbsp;with:
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;trigger: 'LTKF!'
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;reaction: rocket
 &nbsp; &nbsp; &nbsp; &nbsp;env:
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;GITHUB_TOKEN: '${{ secrets.GITHUB_TOKEN }}'

 &nbsp;kubeflow-tests:
 &nbsp; &nbsp;needs: [poetry-install, check_comments]
 &nbsp; &nbsp;# Run this one only when pull-request-comment-trigger was triggered
 &nbsp; &nbsp;if: ${{ needs.check_comments.outputs.kf_trigger == 'true' }}
 &nbsp; &nbsp;uses: ./.github/workflows/kubeflow.yml
</code></pre></div>

 ¬† ¬†‚Äç

> Note: Make sure you add ‚Äòpull_request‚Äô and ‚Äòissue_comment‚Äô to the workflow triggers if you want to use the ‚Äòpull-request-comment-trigger‚Äô.

In our case, if you want to run integration tests on Kubeflow Pipelines specifically, you simply comment ‚ÄòLTKF!‚Äô, short for ‚ÄòLet The Kubes Flow‚Äô.

You may have noticed that there is also a reaction that can be specified reaction: rocket. This might be more gimmick than anything. But isn‚Äôt it the tiny things like this that can take your code from being functional to next level of delightful?

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/03a863d8/6530135507f544ccf062211d_Rocket.png" alt="Comment on PR with a rocket-emoji reaction" />
</figure>

> Note: Using ‚Äòissue-comment‚Äô as a trigger seems to currently be only supported if the workflow with this type of trigger has ended up on the default branch of the repo already. As such this feature is not fully tested on our side yet as it will only reach our main branch in the coming week. I‚Äôll make sure to update this if something changes along the way.

## ‚ôªÔ∏è 5. Reduce wasted compute resources by avoiding unwanted concurrency

I‚Äôm sure this has happened to you before. After some intense hours coding away you are ready to commit and oush your work. Mere seconds after you have pushed and opened your PR you realize that you left something in the code that does not belong. No problem, you think, and within seconds you make the change, commit and push.

Trust me, I‚Äôve been there more times than I care to admit. In these cases I would go into the Github Actions view and manually cancel the Github Action of the first push to free up the runners. But there is an easier way. By defining what the Github Action does in case of concurrency, this can be handled automatically. In our case, we want to cancel the action of the older commit, as we want to know if the most recent code version passes our CI pipeline.

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
 ...

 &nbsp; &nbsp;concurrency:
 &nbsp; &nbsp; &nbsp;# New commit on branch cancels running workflows of the same branch
 &nbsp; &nbsp; &nbsp;group: ${{ github.workflow }}-${{ github.ref }}
 &nbsp; &nbsp; &nbsp;cancel-in-progress: true

...
</code></pre></div>

‚Äç

# üöÄ Our final process (for now)

When I set out on the journey to improve our CI pipelines, the Github Actions weren‚Äôt even part of the plan. All I wanted to do was create a [pytest](https://docs.pytest.org/) fixture that creates a separate virtual environment for each integration test (If this is something that interests you, let us know, and we‚Äôll do a separate blogpost on that whole story). The changes to our Github Actions just happened naturally on the side. The whole process did feel a bit like this though.

<figure id="" class="w-richtext-figure-type-video w-richtext-align-fullwidth" style="padding-bottom:56.25%" data-rt-type="video" data-rt-align="fullwidth" data-rt-max-width="" data-rt-max-height="56.25%" data-rt-dimensions="0:0" data-page-url=""><div id=""><iframe src="https://www.youtube.com/embed/AbSehcT19u0" frameborder="0" allowfullscreen=""></iframe></div></figure>

As of early March 2022 this is the new CI pipeline that we use here at [ZenML](https://github.com/zenml-io/zenml) and the feedback from my colleagues ‚Äì fellow engineers ‚Äì has been very positive overall. I am sure there will be tweaks, changes and refactorings in the future, but for now, this feels Zen.

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/f66172df/653013572b4287a6bf026fc0_newGhActions.gif" alt="Time taken by poetry install" />
</figure>

Check it out yourself [here](https://github.com/zenml-io/zenml/blob/develop/.github/workflows/ci.yml) and feel free to drop in on [Slack](https://zenml.io/slack-invite/) and let us know if this helped you or if you have tips on how we can do even better.

*Alexej Penner is a Machine Learning Engineer at ZenML.*

‚Äç