---
title: "Richify that CLI!"
slug: "richify-that-cli"
draft: false
webflow:
  siteId: "64a817a2e7e2208272d1ce30"
  itemId: "6531e5b58f714c32eba35cd0"
  exportedAt: "2026-02-11T10:23:34.071Z"
  source: "live"
  lastPublished: "2024-08-21T12:26:46.380Z"
  lastUpdated: "2024-08-21T12:26:46.380Z"
  createdOn: "2023-10-20T02:28:05.799Z"
author: "alex-strick-van-linschoten"
category: "tech-startup"
tags:
  - "open-source"
  - "python"
  - "tech-startup"
  - "tooling"
  - "zenml"
date: "2022-02-28T00:00:00.000Z"
readingTime: 8 Mins Read
mainImage:
  url: "https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/938e1cf9/6531e43968722354b8eedf27_rich-terminal.png"
seo:
  title: "Richify that CLI! - ZenML Blog"
  description: "We recently reworked a number of parts of our CLI interface. Here are some quick wins we implemented along the way that can help you improve how users interact with your CLI via the popular open-source library, rich."
  canonical: "https://www.zenml.io/blog/richify-that-cli"
  ogImage: "https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/ccaf9d1e/6531e43968722354b8eedf27_rich-terminal.png"
  ogTitle: "Richify that CLI! - ZenML Blog"
  ogDescription: "We recently reworked a number of parts of our CLI interface. Here are some quick wins we implemented along the way that can help you improve how users interact with your CLI via the popular open-source library, rich."
---

**Last updated:** November 3, 2022.

For an open-source tool without a web frontend, one of the main ways users will interact with [ZenML](https://github.com/zenml-io/zenml) is [our command-line interface or CLI](https://apidocs.zenml.io/0.6.1/cli/). I recently worked on an effort to improve the visual experience of anyone using our CLI by integrating the popular open-source library, [rich](https://github.com/Textualize/rich), into the code base. (This was part of [our latest release](https://blog.zenml.io/zero-six-two-release/), which adds a continuous deployment functionality to ZenML!)

The items that follow are what I consider to be low-hanging fruit for any CLI that is written in Python. You may already have custom solutions or use specific packages that offer certain features. It might be worth considering just getting all of that CLI and terminal goodness from [rich](https://github.com/Textualize/rich), however, given that it does so much for you with relatively little dependency bloating that you perhaps might expect.

## 1. All the Emojis!

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/1278afc9/6531e44bd39f059847141e95_emoji-sampler.png" alt="Some of the emojis available to you in `rich`" />
</figure>

Let‚Äôs cover the important one first üòâ: rich offers full support for emojis in your CLI interfaces. I‚Äôm being slightly flippant here, but only slightly. You may be familiar with emojis as used in chat apps such as the winking face above, but there are hundreds of other, potentially more useful, emojis that you might want to use.

For the ZenML CLI, we went with a ‚úÖ tick emoji to indicate that [an integration](https://zenml.io/integrations) was installed when listing the available and supported integrations. We also chose a üëâ pointing hand emoji to indicate which component or stack was currently activated among the various configurations that we allow you to construct. Nothing too fancy in either case, but I think they‚Äôre more useful and communicative as a user than the other options (like an asterisk, for example). (You‚Äôll see examples of how we used them below.)

You can view a list of all the supported emojis by running python -m rich.emoji (after pip installing rich).

## 2. Markdown parsing

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/341a081c/6531e44b014ba69d939b6676_info-cli.gif" alt="Paging through markdown info about an example" />
</figure>

Our CLI allows users to view information about [the examples we provide](https://blog.zenml.io/examples-cli/) to showcase how ZenML works (and how it can be used). Each example already contains a markdown README.md file with information about the implementation, installation instructions and so on.

We didn‚Äôt want to duplicate work that had already gone into creating those information sheets, so we used them to allow the user to learn about the examples. A simple zenml example info mlflow_tracking was used to output the raw text of the markdown file. For obvious reasons, this wasn‚Äôt satisfactory from a usability perspective.

Now, with rich, we have a way to parse the raw markdown markup and display it as a rich document. What‚Äôs more, we use [the pager](https://rich.readthedocs.io/en/stable/reference/console.html?highlight=pager#rich.console.Console.pager) which gives a familiar interface to anyone interacting with the info document. (In fact, it was searching for an option to handle this markdown parsing that first saw us discover rich and all the other things it does.)

## 3. Beautiful, Informative Tracebacks

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/2543f01b/6531e44c716ca17c9b14133c_rich-traceback.png" alt="A rich traceback" />
</figure>

Errors are often where the rubber meets the road in software projects. When you‚Äôre developing you want those error messages to be informative, clear and not some kind of runic message you have to decode.

With rich, you get a complete redesign of how [tracebacks](https://rich.readthedocs.io/en/stable/traceback.html) are displayed, one that I have found far more useful when trying to understand why a particular code change has caused an error. Moreover, you have the option to have local variables displayed alongside the stack trace message, all neatly boxed up to make it clear what you‚Äôre looking at.

Enabling this as the default way to display Python tracebacks is as simple as adding the following to somewhere that always gets loaded:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
from rich.traceback import install
install(show_locals=True)
</code></pre></div>

‚Äç

## 4. print() gets a makeover

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/50ef2ccf/6531e44c2677456232b354e0_rich-print.png" alt="A rich printout" />
</figure>

Just like tracebacks in rich are better than the Python defaults, you also have [a better print](https://rich.readthedocs.io/en/stable/introduction.html#quick-start). Standard data structures like dicts and lists are converted to strings, syntax highlighting is added and they are clearly presented. (Python already has a tool for this in the standard library ‚Äî pprint ‚Äî though it doesn‚Äôt have the colors.)

We don‚Äôt actually use any print statements in our CLI tool, but through rich our users get access to it for their own purposes, be it debugging or otherwise.

## 5. Inspect your objects

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/451c7c54/6531e44b716ca17c9b14130b_rich-inspect.png" alt="Using rich&#039;s inspect" />
</figure>

I have been using [inspect](https://rich.readthedocs.io/en/stable/introduction.html#rich-inspect) from rich ever since I first saw it used. Like most things in this post, it is a convenience function that offers a better default to standard Python ways of inspecting an object. See the above illustration of what the output looks like. If you pass in methods=True you‚Äôll see what methods can be called on that object. If you pass in docs=True you can read the docstrings for that object.

Like print, we don‚Äôt currently use this anywhere in the outputs of our CLI tool, but we have plans to add some of this output and users have full access to inspect in their own pipelines.

## 6. Status Spinners

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/942f1e7a/66c5dd05f13f1bf6b7471c6a_6531ea4ed882a1570936e53a_ezgif.com-optimize_20_3__20_1_.png" alt="" />
</figure>

When someone tells you that they upgraded their CLI tool, spinners are what you expect. Who doesn‚Äôt love a good spinner!? We added only one (when you call zenml init) but probably will use more as our tool grows.

You can get a good idea of the kinds of spinners available by running python -m rich.status which will output a sort of demo with some spinners. Adding this into your code is painless with a simple context manager:**‚Äç**

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
with console.status("Doing really important work‚Ä¶"):
 &nbsp; &nbsp;# do something here
</code></pre></div>

**‚Äç**

## 7. Progress Bars

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/69b9d429/6531e44b908686517bfa8782_progress-bar.gif" alt="A gif showing the zenml integration install process" />
</figure>

The next step up from a spinner is [a progress bar](https://rich.readthedocs.io/en/stable/progress.html). You get these with rich and they‚Äôre easy to set up:

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
from rich.progress import track

some_iterable = []
for n in track(range(len(some_iterable)), description="Doing important things‚Ä¶"):
 &nbsp; &nbsp;# do something here with the iterable's values 
</code></pre></div>

**

Not only do these progress bars offer a visual indication of your progress, rich also does some background calculations and it suggests an approximate time until completion (based on how quickly you move through the elements).

## 8. Tables

<figure>
  <img src="https://pub-d0f853843b954aadbcd60eaff1d9c6e2.r2.dev/webflow/64a817a2e7e2208272d1ce30/8f2b7ce7/6531610bcf5a73b5a38420cf_rich-tables.jpeg" alt="Our new rich tables" />
</figure>

We use all sorts of [tables](https://rich.readthedocs.io/en/stable/tables.html) in our CLI. We display the integrations you have installed, the stacks you have set up, the examples available for download and so on.

A clear table is an easy win to make it easier for the user to interact with CLI output. You can get much, much more with advanced rich tabular composition features, but probably you don‚Äôt need anything complicated. You just need a table with lines where previously you didn‚Äôt have that.

## 9. Customized message styles

If you have an application of more than minimal complexity you will likely want to have different variations of how you output to the terminal. Maybe you want specific colors for warning or error messages, or there‚Äôs a particular style that should only be used in certain situations. For all that, rich offers a, well, rich API and set of functionality that allows you to output pretty much everything you‚Äôd want to the terminal.

Check out [the docs](https://rich.readthedocs.io/en/stable/console.html) for the full details, but rich will handle any kind of styling and colors that you want to include, justification and alignment within the boundaries of the terminal, soft wrapping, and so on.

## 10. The rich logging handler

<div data-rt-embed-type="true"><pre><code class="language-bash" fs-codehighlight-element="code">
import logging
from rich.logging import RichHandler

# an example of how to set up a rich logger (from the rich docs)
FORMAT = "%(message)s"
logging.basicConfig(
 &nbsp; &nbsp;level="NOTSET", format=FORMAT, datefmt="[%X]", handlers=[RichHandler()]
)

log = logging.getLogger("rich")
log.info("Hello, World!")
</code></pre></div>

‚Äç

We haven‚Äôt fully committed to this yet in the ZenML CLI, but if you want all rich‚Äôs goodies in all of your CLI output, use the rich logging handler. Simply set [the RichHandler](https://rich.readthedocs.io/en/stable/logging.html) as (one of your) logging handlers when you‚Äôre configuring your logging setup.

In this way, you‚Äôll get access to everything that rich offers, except now it‚Äôs in your logs. You probably want to be careful with this, especially if logs are in any sense mission-critical, since the console markup might cause issues when reviewing those logs at a later date. It‚Äôs nevertheless a full-featured way of handling your logging output and if you don‚Äôt already have a custom setup, this is probably worth checking out.

[Let us know](https://zenml.io/slack-invite/) if you end up using these tips and the rich library to spruce up your CLI! Get the latest version of ZenML to use all our latest richified CLI goodness.

*Alex Strick van Linschoten is a Machine Learning Engineer at ZenML.*

‚Äç