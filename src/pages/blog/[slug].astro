---
/**
 * Blog post detail page.
 *
 * Generates a static page for each published blog post.
 * Resolves author, category, tags, and computes prev/next + related posts.
 */
import { getCollection, getEntry, render } from "astro:content";
import BlogLayout from "../../layouts/BlogLayout.astro";
import Badge from "../../components/Badge.astro";
import {
  getAllPublishedPosts,
  getMainFeedPosts,
  getPrevNext,
  getRelatedPosts,
  resolveAuthor,
} from "../../lib/blog";

export async function getStaticPaths() {
  const allPosts = await getAllPublishedPosts();
  const mainFeedPosts = await getMainFeedPosts();

  return allPosts.map((post) => {
    const { prev, next } = getPrevNext(mainFeedPosts, post.data.slug);
    const related = getRelatedPosts(mainFeedPosts, post, 3);

    return {
      params: { slug: post.data.slug },
      props: { post, prev, next, related },
    };
  });
}

const { post, prev, next, related } = Astro.props;
const { Content, headings } = await render(post);

// Resolve author reference
const author = await resolveAuthor(post.data.author);

// Resolve category reference
const categoryEntry = post.data.category
  ? await getEntry("categories", post.data.category)
  : undefined;

// Resolve tag references
const tagEntries = await Promise.all(
  post.data.tags.map((tagSlug: string) => getEntry("tags", tagSlug)),
);
const tags = tagEntries.filter(Boolean).map((t) => ({
  name: t!.data.name,
  slug: t!.data.slug,
}));

// Resolve prev/next/related metadata for cards
const prevAuthor = prev ? await resolveAuthor(prev.data.author) : undefined;
const nextAuthor = next ? await resolveAuthor(next.data.author) : undefined;
const relatedAuthors = new Map<string, { name: string; slug: string }>();
const relatedCategories = new Map<string, { name: string; slug: string }>();
for (const r of related) {
  if (r.data.author && !relatedAuthors.has(r.data.author)) {
    const a = await resolveAuthor(r.data.author);
    if (a) relatedAuthors.set(r.data.author, a);
  }
  if (r.data.category && !relatedCategories.has(r.data.category)) {
    const cat = await getEntry("categories", r.data.category);
    if (cat) relatedCategories.set(r.data.category, { name: cat.data.name, slug: cat.data.slug });
  }
}

// Build SEO props from frontmatter
const seoTitle = post.data.seo?.title || `${post.data.title} - ZenML Blog`;
const seoDescription = post.data.seo?.description;
const ogImage = post.data.seo?.ogImage || post.data.mainImage?.url;
---

<BlogLayout
  title={seoTitle}
  description={seoDescription}
  ogImage={ogImage}
  ogTitle={post.data.seo?.ogTitle}
  ogDescription={post.data.seo?.ogDescription}
  canonical={post.data.seo?.canonical}
  postTitle={post.data.title}
  dek={post.data.seo?.description}
  date={post.data.date}
  author={author}
  category={categoryEntry?.data.name}
  categorySlug={categoryEntry?.data.slug}
  readingTime={post.data.readingTime}
  mainImage={post.data.mainImage}
  headings={headings}
  prev={prev ? { title: prev.data.title, href: `/blog/${prev.data.slug}` } : undefined}
  next={next ? { title: next.data.title, href: `/blog/${next.data.slug}` } : undefined}
  relatedPosts={related.map((r) => {
    const rAuthor = relatedAuthors.get(r.data.author || "");
    const rCat = relatedCategories.get(r.data.category || "");
    return {
      href: `/blog/${r.data.slug}`,
      title: r.data.title,
      excerpt: r.data.seo?.description,
      image: r.data.mainImage,
      authorName: rAuthor?.name,
      authorSlug: rAuthor?.slug,
      readingTime: r.data.readingTime,
      categoryName: rCat?.name,
      categorySlug: rCat?.slug,
    };
  })}
>
  <Content />

  {/* Tags section */}
  {tags.length > 0 && (
    <div class="mt-10 border-t border-gray-200 pt-6">
      <div class="flex flex-wrap gap-2">
        {tags.map((tag) => (
          <Badge href={`/tags/${tag.slug}`} variant="gray">
            {tag.name}
          </Badge>
        ))}
      </div>
    </div>
  )}
</BlogLayout>
